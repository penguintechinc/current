"""
Secure token generation utilities.

Provides cryptographically secure token generation for:
- API keys and access tokens
- Session identifiers
- Password reset tokens
- Email verification tokens
- CSRF tokens
"""

from __future__ import annotations

import base64
import hashlib
import hmac
import secrets
import time
from dataclasses import dataclass
from typing import Optional


@dataclass(slots=True, frozen=True)
class TokenOptions:
    """Configuration options for token generation."""

    length: int = 32  # Token length in bytes (before encoding)
    prefix: str = ""  # Optional prefix for token identification
    include_timestamp: bool = False  # Include creation timestamp


def generate_token(length: int = 32) -> str:
    """
    Generate a cryptographically secure random token.

    Args:
        length: Number of random bytes (default 32 = 256 bits)

    Returns:
        URL-safe base64 encoded token string

    Example:
        >>> token = generate_token()
        >>> len(token) >= 32
        True
    """
    return secrets.token_urlsafe(length)


def generate_hex_token(length: int = 32) -> str:
    """
    Generate a cryptographically secure hex token.

    Args:
        length: Number of random bytes (default 32 = 256 bits)

    Returns:
        Hexadecimal encoded token string

    Example:
        >>> token = generate_hex_token(16)
        >>> len(token)
        32
    """
    return secrets.token_hex(length)


def generate_api_key(prefix: str = "pk") -> str:
    """
    Generate an API key with a prefix for easy identification.

    Format: {prefix}_{base64_token}

    Args:
        prefix: Key prefix (e.g., "pk" for public key, "sk" for secret key)

    Returns:
        Prefixed API key string

    Example:
        >>> key = generate_api_key("sk")
        >>> key.startswith("sk_")
        True
    """
    token = secrets.token_urlsafe(32)
    return f"{prefix}_{token}"


def generate_timestamped_token(length: int = 32) -> str:
    """
    Generate a token that includes a timestamp component.

    The timestamp allows for token expiration checks without database lookup.
    Format: {timestamp_hex}_{random_token}

    Args:
        length: Number of random bytes for the token part

    Returns:
        Timestamped token string

    Example:
        >>> token = generate_timestamped_token()
        >>> "_" in token
        True
    """
    timestamp = int(time.time())
    timestamp_hex = format(timestamp, "x")
    random_part = secrets.token_urlsafe(length)
    return f"{timestamp_hex}_{random_part}"


def extract_timestamp(timestamped_token: str) -> Optional[int]:
    """
    Extract the timestamp from a timestamped token.

    Args:
        timestamped_token: Token generated by generate_timestamped_token()

    Returns:
        Unix timestamp or None if invalid format

    Example:
        >>> token = generate_timestamped_token()
        >>> ts = extract_timestamp(token)
        >>> ts is not None
        True
    """
    try:
        parts = timestamped_token.split("_", 1)
        if len(parts) != 2:
            return None
        return int(parts[0], 16)
    except (ValueError, TypeError):
        return None


def is_token_expired(timestamped_token: str, max_age_seconds: int) -> bool:
    """
    Check if a timestamped token has expired.

    Args:
        timestamped_token: Token generated by generate_timestamped_token()
        max_age_seconds: Maximum age in seconds

    Returns:
        True if expired or invalid, False if still valid

    Example:
        >>> token = generate_timestamped_token()
        >>> is_token_expired(token, 3600)  # 1 hour
        False
    """
    timestamp = extract_timestamp(timestamped_token)
    if timestamp is None:
        return True

    current_time = int(time.time())
    return (current_time - timestamp) > max_age_seconds


def generate_signed_token(
    payload: str,
    secret_key: str,
    expires_in: Optional[int] = None,
) -> str:
    """
    Generate a signed token with optional expiration.

    The token includes the payload, timestamp, and HMAC signature.
    Format: {base64_payload}.{timestamp}.{signature}

    Args:
        payload: String payload to include in token
        secret_key: Secret key for HMAC signing
        expires_in: Optional expiration time in seconds

    Returns:
        Signed token string

    Example:
        >>> token = generate_signed_token("user:123", "secret")
        >>> "." in token
        True
    """
    timestamp = int(time.time())
    if expires_in:
        expiry = timestamp + expires_in
    else:
        expiry = 0  # 0 means no expiration

    # Encode payload
    payload_b64 = base64.urlsafe_b64encode(payload.encode()).decode().rstrip("=")

    # Create message to sign
    message = f"{payload_b64}.{timestamp}.{expiry}"

    # Generate HMAC signature
    signature = hmac.new(
        secret_key.encode(),
        message.encode(),
        hashlib.sha256,
    ).hexdigest()[:32]  # Use first 32 chars of hex digest

    return f"{message}.{signature}"


def verify_signed_token(token: str, secret_key: str) -> Optional[str]:
    """
    Verify a signed token and return the payload if valid.

    Args:
        token: Signed token from generate_signed_token()
        secret_key: Secret key used for signing

    Returns:
        Original payload if valid and not expired, None otherwise

    Example:
        >>> token = generate_signed_token("user:123", "secret", expires_in=3600)
        >>> payload = verify_signed_token(token, "secret")
        >>> payload
        'user:123'
    """
    try:
        parts = token.split(".")
        if len(parts) != 4:
            return None

        payload_b64, timestamp_str, expiry_str, signature = parts

        # Verify signature
        message = f"{payload_b64}.{timestamp_str}.{expiry_str}"
        expected_sig = hmac.new(
            secret_key.encode(),
            message.encode(),
            hashlib.sha256,
        ).hexdigest()[:32]

        if not hmac.compare_digest(signature, expected_sig):
            return None

        # Check expiration
        expiry = int(expiry_str)
        if expiry > 0 and int(time.time()) > expiry:
            return None

        # Decode payload (add padding if needed)
        padding = 4 - (len(payload_b64) % 4)
        if padding != 4:
            payload_b64 += "=" * padding

        payload = base64.urlsafe_b64decode(payload_b64).decode()
        return payload

    except (ValueError, TypeError, UnicodeDecodeError):
        return None


def generate_password_reset_token(user_id: str, secret_key: str) -> str:
    """
    Generate a password reset token for a user.

    Token expires in 1 hour by default.

    Args:
        user_id: User identifier
        secret_key: Application secret key

    Returns:
        Password reset token
    """
    return generate_signed_token(f"reset:{user_id}", secret_key, expires_in=3600)


def verify_password_reset_token(
    token: str,
    secret_key: str,
) -> Optional[str]:
    """
    Verify a password reset token and return the user ID.

    Args:
        token: Password reset token
        secret_key: Application secret key

    Returns:
        User ID if valid, None otherwise
    """
    payload = verify_signed_token(token, secret_key)
    if payload and payload.startswith("reset:"):
        return payload[6:]  # Remove "reset:" prefix
    return None


def generate_email_verification_token(email: str, secret_key: str) -> str:
    """
    Generate an email verification token.

    Token expires in 24 hours by default.

    Args:
        email: Email address to verify
        secret_key: Application secret key

    Returns:
        Email verification token
    """
    return generate_signed_token(f"verify:{email}", secret_key, expires_in=86400)


def verify_email_verification_token(
    token: str,
    secret_key: str,
) -> Optional[str]:
    """
    Verify an email verification token and return the email.

    Args:
        token: Email verification token
        secret_key: Application secret key

    Returns:
        Email address if valid, None otherwise
    """
    payload = verify_signed_token(token, secret_key)
    if payload and payload.startswith("verify:"):
        return payload[7:]  # Remove "verify:" prefix
    return None


def constant_time_compare(a: str, b: str) -> bool:
    """
    Compare two strings in constant time to prevent timing attacks.

    Args:
        a: First string
        b: Second string

    Returns:
        True if strings are equal, False otherwise
    """
    return hmac.compare_digest(a.encode(), b.encode())
